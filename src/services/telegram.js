const TelegramBot = require('node-telegram-bot-api');
const { HttpsProxyAgent } = require('https-proxy-agent');
const { logger } = require('../utils/logger');

class TelegramService {
  constructor(config, enablePolling = false) {
    this.config = config;
    this.bot = null;
    this.chatId = config.telegram.chatId;

    // Daily alert count: Map<"symbol-interval-direction", count>
    this.dailyAlertCount = new Map();

    // Cooldown: Map<"symbol-interval-direction", timestamp>
    this.cooldownMap = new Map();

    if (config.telegram.botToken) {
      const botOptions = { polling: enablePolling };  // Enable polling for commands
      if (config.proxy.httpsProxy) {
        botOptions.request = {
          agentClass: HttpsProxyAgent,
          agentOptions: { proxy: config.proxy.httpsProxy },
        };
      }
      this.bot = new TelegramBot(config.telegram.botToken, botOptions);
      this.startDailyReset();
    }
  }

  /**
   * Reset daily count at midnight
   */
  startDailyReset() {
    const now = new Date();
    const tomorrow = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 0, 0, 0);
    const msUntilMidnight = tomorrow - now;

    setTimeout(() => {
      this.dailyAlertCount.clear();
      logger.info('Daily alert count reset.');
      setInterval(() => {
        this.dailyAlertCount.clear();
        logger.info('Daily alert count reset.');
      }, 24 * 60 * 60 * 1000);
    }, msUntilMidnight);
  }

  /**
   * Check if symbol is in cooldown
   */
  isInCooldown(symbol, interval, direction) {
    const key = `${symbol}-${interval}-${direction}`;
    const lastTime = this.cooldownMap.get(key);
    if (!lastTime) return false;

    const elapsed = (Date.now() - lastTime) / 1000 / 60;
    return elapsed < this.config.monitor.cooldownMinutes;
  }

  /**
   * Record alert time for cooldown
   */
  recordAlertTime(symbol, interval, direction) {
    const key = `${symbol}-${interval}-${direction}`;
    this.cooldownMap.set(key, Date.now());
  }

  /**
   * Get and increment alert count
   */
  getAndIncrementAlertCount(symbol, interval, direction) {
    const key = `${symbol}-${interval}-${direction}`;
    const current = this.dailyAlertCount.get(key) || 0;
    const newCount = current + 1;
    this.dailyAlertCount.set(key, newCount);
    return newCount;
  }

  /**
   * Format price with dynamic precision
   */
  formatPrice(price) {
    if (price >= 1000) return price.toFixed(2);
    if (price >= 1) return price.toFixed(4);
    if (price >= 0.01) return price.toFixed(6);
    return price.toFixed(8);
  }

  /**
   * Get formatted time string (server local time, 24-hour format)
   * Ê†ºÂºè: YYYY-MM-DD HH:mm:ss
   */
  getTimeString() {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const date = String(now.getDate()).padStart(2, '0');
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    const seconds = String(now.getSeconds()).padStart(2, '0');
    
    return `${year}-${month}-${date} ${hours}:${minutes}:${seconds}`;
  }

  /**
   * Get formatted hour string (for reports)
   */
  getHourString() {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const date = String(now.getDate()).padStart(2, '0');
    const hours = String(now.getHours()).padStart(2, '0');
    
    return `${year}-${month}-${date} ${hours}:00`;
  }

  /**
   * Get timeframe emoji color
   */
  getTimeframeEmoji(interval) {
    const map = {
      '5m': 'üî¥',
      '15m': 'üü°',
      '1h': 'üü¢',
      '4h': 'üîµ',
      '1d': 'üü£',
    };
    return map[interval] || '‚ö™';
  }

  /**
   * Calculate comprehensive rating and analysis
   */
  analyzeSignal(data) {
    const { priceChange, rsi, trend, volumeMultiplier, adx, currentPrice, ema7, ema25, symbol, quoteVolume, btcMarketCondition } = data;
    const direction = priceChange > 0 ? 'up' : 'down';

    let rating = 'C';
    let suggestion = 'Á≠âÂæÖËßÇÂØü';
    let reasons = [];
    let warnings = [];

    // ADX trend strength
    const trendStrong = adx >= 25;
    const trendWeak = adx <= 18;

    // Volume
    const volumeHigh = volumeMultiplier >= 2.5;
    const volumeNormal = volumeMultiplier >= 1.5 && volumeMultiplier < 2.5;
    const volumeLow = volumeMultiplier < 1.5;

    // RSI
    const rsiOverbought = rsi >= 70;
    const rsiOversold = rsi <= 30;
    const rsiNeutral = rsi > 30 && rsi < 70;

    // BTC market filter (for altcoins)
    const isAltcoin = symbol !== 'BTCUSDT' && symbol !== 'ETHUSDT';
    const btcBearish = btcMarketCondition && btcMarketCondition.trend === 'bearish' && btcMarketCondition.adx >= 25;
    const btcBullish = btcMarketCondition && btcMarketCondition.trend === 'bullish' && btcMarketCondition.adx >= 25;

    // Low liquidity check
    const lowLiquidity = quoteVolume < 1000000; // < 100‰∏á USDT

    if (direction === 'up') {
      // Bullish analysis
      if (trend === 'bullish' && volumeHigh && rsiNeutral && trendStrong) {
        rating = 'A';
        suggestion = 'ÂèØËÄÉËôëÂÅöÂ§ö';
        reasons.push('‚úÖ Â§öÂ§¥Ë∂ãÂäøÁ°ÆËÆ§');
        reasons.push('‚úÖ ÊîæÈáè‰∏äÊ∂®ÔºàÊúâ‰π∞ÁõòÔºâ');
        reasons.push('‚úÖ Ë∂ãÂäøÂº∫Âä≤ÔºàADXÈ´òÔºâ');
        
        // BTC filter for altcoins
        if (isAltcoin && btcBearish) {
          rating = 'C';
          suggestion = 'ËßÇÊúõÔºàÂ§ßÁõòÂº±ÂäøÔºâ';
          reasons.push('‚ö†Ô∏è BTCÁ©∫Â§¥Âº∫ÂäøÔºåÂ±±ÂØ®Â∏ÅÈ£éÈô©È´ò');
        }
      } else if (trend === 'bullish' && volumeNormal && rsiNeutral) {
        rating = 'B';
        suggestion = 'Ë∞®ÊÖéÂÅöÂ§ö';
        reasons.push('‚úÖ Â§öÂ§¥Ë∂ãÂäø‰∏≠');
        reasons.push('‚ö†Ô∏è ÈáèËÉΩ‰∏ÄËà¨');
        
        if (isAltcoin && btcBearish) {
          rating = 'C';
          suggestion = '‰∏çÂª∫ËÆÆÂÅöÂ§öÔºàÂ§ßÁõòÂº±Ôºâ';
        }
      } else if (trend === 'bullish' && rsiOverbought) {
        rating = 'C';
        suggestion = '‰∏çÂª∫ËÆÆËøΩÈ´ò';
        reasons.push('‚úó RSIË∂Ö‰π∞ÔºàÂÆπÊòìÂõûË∞ÉÔºâ');
        warnings.push('‚ö†Ô∏è Ë∂Ö‰π∞ËøΩÈ´òÈ£éÈô©');
      } else if (trend === 'bearish') {
        rating = 'C';
        suggestion = '‰∏çÂª∫ËÆÆËøΩ';
        reasons.push('‚úó ÈÄÜÂäøÂèçÂºπÔºà‰∏ãË∑åË∂ãÂäø‰∏≠Ôºâ');
        if (volumeHigh && trendWeak) {
          warnings.push('üö® Â∫ÑÂÆ∂ËØ±Â§öË≠¶Á§∫ÔºöÈúáËç°Âå∫Âº∫ÊãâÔºåÈ´ò‰ΩçÊé•ÁõòÈ£éÈô©Â§ß');
        } else if (volumeLow) {
          warnings.push('‚ö†Ô∏è Áº©ÈáèÂèçÂºπÔºåÂ§ö‰∏∫ËØ±Â§ö');
        }
      } else if (volumeLow && Math.abs(priceChange) > 5) {
        rating = 'C';
        suggestion = 'Ë≠¶ÊÉïËØ±Â§ö';
        reasons.push('‚úó Èáè‰ª∑ËÉåÁ¶ªÔºàÊ∂®‰ΩÜÊó†ÈáèÔºâ');
        warnings.push('üö® Â∫ÑÂÆ∂ÂØπÊï≤Ë≠¶Á§∫ÔºöÂ§ßÊ∂®Áº©ÈáèÔºåÊï£Êà∑ËøΩÈ´òÊòìË¢´Â•ó');
      }
    } else {
      // Bearish analysis
      if (trend === 'bearish' && volumeHigh && rsiNeutral && trendStrong) {
        rating = 'A';
        suggestion = 'ÂèØËÄÉËôëÂÅöÁ©∫';
        reasons.push('‚úÖ Á©∫Â§¥Ë∂ãÂäøÁ°ÆËÆ§');
        reasons.push('‚úÖ ÊîæÈáè‰∏ãË∑åÔºàÊäõÂéãÂ§ßÔºâ');
        reasons.push('‚úÖ Ë∂ãÂäøÂº∫Âä≤ÔºàADXÈ´òÔºâ');
      } else if (trend === 'bearish' && volumeNormal && rsiNeutral) {
        rating = 'B';
        suggestion = 'Ë∞®ÊÖéÂÅöÁ©∫';
        reasons.push('‚úÖ Á©∫Â§¥Ë∂ãÂäø‰∏≠');
        reasons.push('‚ö†Ô∏è ÈáèËÉΩ‰∏ÄËà¨');
      } else if (trend === 'bearish' && rsiOversold) {
        rating = 'C';
        suggestion = 'Á≠âÂæÖ‰ºÅÁ®≥';
        reasons.push('‚úó RSIË∂ÖÂçñÔºàÂèØËÉΩÂèçÂºπÔºâ');
      } else if (trend === 'bullish') {
        rating = 'C';
        suggestion = '‰∏çÂª∫ËÆÆÂÅöÁ©∫';
        reasons.push('‚úó ÈÄÜÂäøÂõûË∞ÉÔºà‰∏äÊ∂®Ë∂ãÂäø‰∏≠Ôºâ');
        if (volumeHigh) {
          warnings.push('‚ö†Ô∏è Â§öÂ§¥ÂõûË∞ÉÔºåÂèØËÉΩÊòØÊ¥óÁõò');
        }
      } else if (volumeLow && Math.abs(priceChange) > 5) {
        rating = 'C';
        suggestion = 'ËßÇÊúõ';
        reasons.push('‚úó Èò¥Ë∑åÁº©ÈáèÔºàÊÖ¢ÊÖ¢Á£®Ôºâ');
        warnings.push('‚ö†Ô∏è Â∞èÂ∏ÅÁßçÈ£éÈô©ÔºöÁº∫‰πèÊµÅÂä®ÊÄßÔºåÊòìÊö¥Ë∑å');
      }
    }

    // Additional warnings for weak trends
    if (trendWeak && Math.abs(priceChange) > 5) {
      warnings.push('‚ö†Ô∏è ÈúáËç°Â∏ÇÊãâÂçáÔºåÂÅáÁ™ÅÁ†¥Ê¶ÇÁéáÈ´ò');
    }

    // Small cap coin warning
    if (currentPrice < 0.1 && volumeMultiplier < 2) {
      warnings.push('‚ö†Ô∏è Â∞èÂ∏ÇÂÄºÂ∏ÅÁßçÔºåÂ∫ÑÂÆ∂ÊéßÁõòÈ£éÈô©È´ò');
    }

    // Low liquidity warning
    if (lowLiquidity && Math.abs(priceChange) > 5) {
      warnings.push('‚ö†Ô∏è Êàê‰∫§È¢ùËøá‰ΩéÔºàÊµÅÂä®ÊÄßÂ∑ÆÔºâÔºåÊòìË¢´ÊìçÊéß');
    }

    // Extreme volatility warning
    if (Math.abs(priceChange) > 30 && volumeMultiplier < 2) {
      warnings.push('üö® ÊûÅÁ´ØÊ≥¢Âä®+Áº©ÈáèÔºöÂ∫ÑÂÆ∂ÊéßÁõòÔºåËøúÁ¶ªÔºÅ');
    }

    return { rating, suggestion, reasons, warnings };
  }

  /**
   * Send alert message
   */
  async sendAlert(data) {
    if (!this.bot || !this.chatId) {
      logger.warn('Telegram bot not configured.');
      return;
    }

    const { symbol, interval, priceChange, currentPrice, volumeMultiplier, quoteVolume, rsi, ema7, ema25, adx, trend, supportLevel, resistanceLevel } = data;

    const direction = priceChange > 0 ? 'up' : 'down';
    const directionText = priceChange > 0 ? '‰∏äÊ∂®' : '‰∏ãË∑å';

    // Check cooldown
    if (this.isInCooldown(symbol, interval, direction)) {
      logger.debug(`Skipped ${symbol} ${interval} ${directionText} (cooldown).`);
      return;
    }

    // Get alert count
    const alertCount = this.getAndIncrementAlertCount(symbol, interval, direction);

    // Record cooldown
    this.recordAlertTime(symbol, interval, direction);

    // Analysis
    const { rating, suggestion, reasons, warnings } = this.analyzeSignal(data);

    // Timeframe display
    const emoji = this.getTimeframeEmoji(interval);
    const threshold = this.config.monitor.thresholds[interval] || 0;

    // Format time (24-hour)
    const timeStr = this.getTimeString();

    // RSI status
    let rsiStatus = 'üìä ‰∏≠ÊÄß';
    if (rsi >= 70) rsiStatus = '‚ö†Ô∏è Ë∂Ö‰π∞';
    else if (rsi <= 30) rsiStatus = '‚ö†Ô∏è Ë∂ÖÂçñ';
    else if (rsi >= 60) rsiStatus = '‚úÖ Âº∫Âäø';
    else if (rsi <= 40) rsiStatus = 'üìä Âº±Âäø';

    // Trend status
    let trendIcon = '‚û°Ô∏è ÈúáËç°';
    if (trend === 'bullish') trendIcon = 'üöÄ Â§öÂ§¥ÊéíÂàó';
    else if (trend === 'bearish') trendIcon = 'üìâ Á©∫Â§¥ÊéíÂàó';

    // Volume tag
    let volumeTag = 'üìä Ê≠£Â∏∏';
    if (volumeMultiplier >= 3) volumeTag = 'üí• ÁàÜÈáè';
    else if (volumeMultiplier >= 2) volumeTag = '‚ö° ÊîæÈáè';
    else if (volumeMultiplier < 1) volumeTag = 'üìâ Áº©Èáè';

    // ADX status
    let adxStatus = '';
    if (adx >= 25) adxStatus = 'ÔºàË∂ãÂäøÂº∫Ôºâ';
    else if (adx <= 18) adxStatus = 'ÔºàÈúáËç°Ôºâ';
    else adxStatus = 'ÔºàËøáÊ∏°Ôºâ';

    // Build message
    let message = `üìä ÂêàÁ∫¶‰ª∑Ê†ºÂºÇÂä®ÊèêÈÜíÔºà${symbol} Á¨¨${alertCount}Ê¨°ÊèêÈÜíÔºâ\n\n`;
    message += `‰∫§ÊòìÂØπ: ${symbol}\n`;
    message += `Âë®Êúü: ${emoji} ${interval}\n`;
    message += `ÂèòÂä®ÂπÖÂ∫¶: ${priceChange > 0 ? '+' : ''}${priceChange.toFixed(2)}% (${directionText})\n`;
    message += `ÈòàÂÄº: ${threshold}%\n`;
    message += `ÂΩìÂâç‰ª∑Ê†º: ${this.formatPrice(currentPrice)}\n\n`;

    message += `üìà ÊäÄÊúØÂàÜÊûê:\n`;
    message += `‚Ä¢ RSI(14): ${rsi.toFixed(0)} ${rsiStatus}\n`;
    message += `‚Ä¢ MAË∂ãÂäø: ${trendIcon}\n`;
    message += `‚Ä¢ EMA7: ${this.formatPrice(ema7)} | EMA25: ${this.formatPrice(ema25)}\n`;
    message += `‚Ä¢ ÈáèËÉΩ: ${volumeTag} ${volumeMultiplier.toFixed(1)}x\n`;
    message += `‚Ä¢ ADX: ${adx.toFixed(0)} ${adxStatus}\n\n`;

    message += `üí∞ ÂèÇËÄÉ‰ΩçÁΩÆ:\n`;
    message += `‚Ä¢ ÊîØÊíë‰Ωç: $${this.formatPrice(supportLevel)}\n`;
    message += `‚Ä¢ ÈòªÂäõ‰Ωç: $${this.formatPrice(resistanceLevel)}\n\n`;

    // Pattern recognition (if available)
    if (data.patternAnalysis && data.patternAnalysis.patterns.length > 0) {
      message += `üîç ÂΩ¢ÊÄÅËØÜÂà´:\n`;
      message += `‚Ä¢ ${data.patternAnalysis.summary}\n`;
      
      if (data.patternAnalysis.fusionSignals.length > 0) {
        const fusionSignal = data.patternAnalysis.fusionSignals[0];
        message += `‚Ä¢ ${fusionSignal.emoji} ${fusionSignal.description}\n`;
      }
      message += `\n`;
    }

    message += `üí° ÁªºÂêàËØÑÁ∫ß: ${rating}Á∫ß‰ø°Âè∑\n`;
    
    // Use pattern recommendation if available and high confidence
    if (data.patternRecommendation && data.patternAnalysis.overallConfidence >= 75) {
      message += `${data.patternRecommendation.emoji} ÂΩ¢ÊÄÅÂª∫ËÆÆ: ${data.patternRecommendation.reason}\n`;
    }
    
    message += `${priceChange > 0 ? '‚úÖ' : '‚ö†Ô∏è'} Âª∫ËÆÆÊñπÂêë: ${suggestion}\n\n`;

    if (reasons.length > 0) {
      message += `üìù ÂéüÂõ†ÂàÜÊûê:\n`;
      reasons.forEach(r => {
        message += `${r}\n`;
      });
      message += `\n`;
    }

    if (warnings.length > 0) {
      message += `‚ö†Ô∏è È£éÈô©Ë≠¶Á§∫:\n`;
      warnings.forEach(w => {
        message += `${w}\n`;
      });
      message += `\n`;
    }

    message += `Êó∂Èó¥: ${timeStr}`;

    try {
      await this.bot.sendMessage(this.chatId, message);
      logger.info(`Alert sent: ${symbol} ${interval} ${directionText} (${alertCount})`);
    } catch (err) {
      logger.error(`Failed to send alert: ${err.message}`);
    }
  }

  /**
   * Send ambush coin report (ËûçÂêàÊó•Á∫ø+Â∞èÊó∂Á∫ø)
   */
  async sendAmbushReport(candidates) {
    if (!this.bot || !this.chatId || !candidates || candidates.length === 0) {
      return;
    }

    const timeStr = this.getHourString();

    let message = `üîç Âüã‰ºèÂ∏ÅÊâ´ÊèèÊä•ÂëäÔºà${timeStr}Ôºâ\n\n`;
    message += `üìä ËûçÂêàËØÑÂàÜÁ≥ªÁªüÔºàÊó•Á∫ø+Â∞èÊó∂Á∫øÔºâ\n`;
    message += `ÂèëÁé∞ ${candidates.length} ‰∏™ÊΩúÂäõÂ∏ÅÁßçÔºö\n\n`;

    candidates.forEach((coin, index) => {
      message += `${index + 1}. ${coin.symbol}\n`;
      
      // ËûçÂêàËØÑÂàÜÊòæÁ§∫
      const totalScore = coin.totalScore || coin.score || 0;
      const dailyScore = coin.dailyScore || coin.score || 0;
      const hourlyScore = coin.hourlyScore || 0;
      
      if (hourlyScore > 0) {
        message += `   üìà ÊÄªÂàÜ: ${totalScore}/20 (Êó•${dailyScore} + Êó∂${hourlyScore}) `;
      } else {
        message += `   üìà Êó•Á∫øËØÑÂàÜ: ${dailyScore}/15 `;
      }
      
      // Add star rating
      const stars = '‚≠ê'.repeat(Math.min(Math.floor(totalScore / 4), 5));
      message += `${stars}\n`;
      
      message += `   üí∞ ÂΩìÂâç‰ª∑: $${this.formatPrice(coin.currentPrice)}\n`;
      message += `   üìâ Ë∑ù30Êó•È´òÁÇπ: -${(coin.drawdownFrom30dHigh * 100).toFixed(1)}%\n`;
      message += `   üìä Ë∑ù60Êó•‰ΩéÁÇπ: +${(coin.distanceFromLow * 100).toFixed(1)}%\n`;
      message += `   üìà RSI(Êó•): ${coin.rsi.toFixed(0)}`;
      
      if (coin.rsiRising) message += ' ‚¨ÜÔ∏è';
      message += `\n`;
      
      message += `   üîÑ EMAÈáëÂèâË∑ùÁ¶ª: ${Math.abs(coin.emaGap * 100).toFixed(2)}%\n`;
      message += `   ‚è∞ Êï¥ÁêÜÂ§©Êï∞: ${coin.consolidationDays}Â§©\n`;
      
      // Â∞èÊó∂Á∫ø‰ø°Âè∑
      if (coin.hourlySignals && coin.hourlySignals.length > 0) {
        message += `   ‚ö° Â∞èÊó∂Á∫ø: ${coin.hourlySignals.join(', ')}\n`;
      }
      
      message += `\n`;
    });

    message += `üí° ËØ¥ÊòéÔºö\n`;
    message += `‚Ä¢ üìä ËûçÂêàËØÑÂàÜÔºöÊó•Á∫ø(Â∫ïÈÉ®ÂΩ¢ÊÄÅ) + Â∞èÊó∂Á∫ø(Âä®ÊÄÅ‰ø°Âè∑)\n`;
    message += `‚Ä¢ ‚≠ê ËØÑÂàÜ ‚â•7 Ëá™Âä®Âä†ÂÖ•ËßÇÂØüÊ±†\n`;
    message += `‚Ä¢ üîç ÊØè5ÂàÜÈíüÊ£ÄÊµãÂÖ•Âú∫‰ø°Âè∑ÔºàEMAÈáëÂèâ/ÊîæÈáèÁ™ÅÁ†¥Ôºâ\n`;
    message += `‚Ä¢ ‚è∞ ‰∏ãÊ¨°Êâ´ÊèèÔºö6Â∞èÊó∂Âêé\n\n`;
    message += `‚ö†Ô∏è È£éÈô©ÊèêÁ§∫ÔºöÂ∫ïÈÉ®ÂΩ¢ÊÄÅÈúÄË¶ÅÊó∂Èó¥Á°ÆËÆ§ÔºåËØ∑ÊéßÂà∂‰ªì‰ΩçÔºÅ`;

    try {
      await this.bot.sendMessage(this.chatId, message);
      logger.info(`Ambush report sent with ${candidates.length} candidates (ËûçÂêàËØÑÂàÜ)`);
    } catch (err) {
      logger.error(`Failed to send ambush report: ${err.message}`);
    }
  }

  /**
   * Send entry signal (when watchlist coin triggers golden cross)
   */
  async sendEntrySignal(signal) {
    if (!this.bot || !this.chatId) {
      return;
    }

    const timeStr = this.getTimeString();

    let message = `üöÄ Âüã‰ºèÂ∏ÅÂÖ•Âú∫‰ø°Âè∑\n\n`;
    message += `‰∫§ÊòìÂØπ: ${signal.symbol}\n`;
    message += `‰ø°Âè∑Á±ªÂûã: ${signal.signalType}\n`;
    message += `ËßÇÂØüÊ±†ËØÑÂàÜ: ${signal.watchlistScore}/20+\n`;
    message += `ÂΩìÂâç‰ª∑Ê†º: $${this.formatPrice(signal.currentPrice)}\n\n`;

    message += `üìä ÊäÄÊúØÁ°ÆËÆ§:\n`;
    message += `‚Ä¢ EMA7: ${this.formatPrice(signal.ema7)}\n`;
    message += `‚Ä¢ EMA25: ${this.formatPrice(signal.ema25)}\n`;
    message += `‚Ä¢ ÈáèËÉΩ: ${signal.volumeMultiplier}x (${signal.volumeConfirm ? '‚úÖ' : '‚ö†Ô∏è'})\n`;
    message += `‚Ä¢ RSI(14): ${signal.rsi}\n`;
    message += `‚Ä¢ ÁΩÆ‰ø°Â∫¶: ${signal.confidence}%\n`;
    if (signal.btcTrend) {
      const btcEmoji = signal.btcTrend === 'bullish' ? 'üü¢' : 'üî¥';
      message += `‚Ä¢ BTCË∂ãÂäø: ${btcEmoji} ${signal.btcTrend === 'bullish' ? 'Â§öÂ§¥' : 'Á©∫Â§¥'}\n`;
    }
    message += `\n`;

    message += `‚úÖ Ëß¶ÂèëÂéüÂõ†:\n`;
    if (signal.reasons && signal.reasons.length > 0) {
      signal.reasons.forEach(reason => {
        message += `‚Ä¢ ${reason}\n`;
      });
    }
    message += `\n`;

    message += `üí° Êìç‰ΩúÂª∫ËÆÆ:\n`;
    if (signal.volumeConfirm && signal.confidence >= 80) {
      message += `‚úÖ Âª∫ËÆÆËØïÊé¢ÊÄßÂÖ•Âú∫\n`;
      message += `‚Ä¢ Âª∫ËÆÆ‰ªì‰Ωç: 5-10%\n`;
      message += `‚Ä¢ Ê≠¢Êçü‰Ωç: EMA25 ‰∏ãÊñπÔºà$${this.formatPrice(signal.ema25 * 0.97)}Ôºâ\n`;
      message += `‚Ä¢ Ê≠¢Áõà‰Ωç: +10~15%\n`;
    } else {
      message += `‚ö†Ô∏è Ë∞®ÊÖéËßÇÊúõ\n`;
      message += `‚Ä¢ ‰ø°Âè∑Âº∫Â∫¶‰∏çÂ§üÔºåÂª∫ËÆÆÁ≠âÂæÖ\n`;
      message += `‚Ä¢ ÂÖ≥Ê≥®ÈáèËÉΩÊòØÂê¶ÊåÅÁª≠ÊîæÂ§ß\n`;
    }
    
    if (signal.warning) {
      message += `\n${signal.warning}\n`;
    }

    message += `\n‚è∞ ${timeStr}`;

    try {
      await this.bot.sendMessage(this.chatId, message);
      logger.info(`Entry signal sent: ${signal.symbol}`);
    } catch (err) {
      logger.error(`Failed to send entry signal: ${err.message}`);
    }
  }

  /**
   * Send position alert (stop loss / take profit / etc.)
   */
  async sendPositionAlert(alertData) {
    if (!this.bot || !this.chatId) return;

    const { type, position, currentPrice, pnl } = alertData;
    const dirText = position.direction === 'long' ? 'Â§öÂ§¥' : 'Á©∫Â§¥';

    const timeStr = this.getTimeString();

    let message = '';

    switch (type) {
      case 'stop_loss':
        message = `üö® Ê≠¢ÊçüÊèêÈÜí\n\n`;
        message += `‰∫§ÊòìÂØπ: ${position.symbol} (${dirText})\n`;
        message += `ÂÖ•Âú∫‰ª∑: $${this.formatPrice(position.entryPrice)}\n`;
        message += `ÂΩìÂâç‰ª∑: $${this.formatPrice(currentPrice)}\n`;
        message += `Ê≠¢Êçü‰ª∑: $${this.formatPrice(position.stopLoss)}\n`;
        message += `Áõà‰∫è: ${pnl >= 0 ? '+' : ''}${pnl.toFixed(2)}%\n\n`;
        message += `‚ö†Ô∏è Âª∫ËÆÆ: Á´ãÂç≥Ê≠¢ÊçüÁ¶ªÂú∫ÔºåÊéßÂà∂ÊçüÂ§±\n`;
        message += `\n‚è∞ ${timeStr}`;
        break;

      case 'take_profit':
        const tpEmojis = ['üéØ', 'üéâ', 'üíé'];
        const tpPercents = ['50%', '30%', '20%'];
        message = `${tpEmojis[alertData.tpLevel - 1]} Ê≠¢Áõà${alertData.tpLevel}ÊèêÈÜí\n\n`;
        message += `‰∫§ÊòìÂØπ: ${position.symbol} (${dirText})\n`;
        message += `ÂÖ•Âú∫‰ª∑: $${this.formatPrice(position.entryPrice)}\n`;
        message += `ÂΩìÂâç‰ª∑: $${this.formatPrice(currentPrice)}\n`;
        message += `Ê≠¢Áõà${alertData.tpLevel}: $${this.formatPrice(alertData.tpPrice)}\n`;
        message += `Áõà‰∫è: +${pnl.toFixed(2)}%\n\n`;
        message += `üí° Âª∫ËÆÆ: Âπ≥Êéâ ${tpPercents[alertData.tpLevel - 1]} ‰ªì‰ΩçÔºåÈîÅÂÆöÂà©Ê∂¶\n`;
        if (alertData.tpLevel === 1) {
          message += `Ââ©‰Ωô‰ªì‰ΩçÁªßÁª≠ÊåÅÊúâÔºåÊ≠¢ÊçüÁßªËá≥ÊàêÊú¨‰ª∑\n`;
        }
        message += `\n‚è∞ ${timeStr}`;
        break;

      case 'rsi_extreme':
        const rsiEmoji = position.direction === 'long' ? '‚ö†Ô∏è' : 'üí°';
        message = `${rsiEmoji} RSI ${alertData.message}\n\n`;
        message += `‰∫§ÊòìÂØπ: ${position.symbol} (${dirText})\n`;
        message += `ÂÖ•Âú∫‰ª∑: $${this.formatPrice(position.entryPrice)}\n`;
        message += `ÂΩìÂâç‰ª∑: $${this.formatPrice(currentPrice)}\n`;
        message += `RSI: ${alertData.rsi.toFixed(0)}\n`;
        message += `Áõà‰∫è: ${pnl >= 0 ? '+' : ''}${pnl.toFixed(2)}%\n\n`;
        message += `üí° Âª∫ËÆÆ: ËÄÉËôëÂàÜÊâπÊ≠¢ÁõàÔºåÊàñÁßªÂä®Ê≠¢Êçü‰øùÊä§Âà©Ê∂¶\n`;
        message += `\n‚è∞ ${timeStr}`;
        break;

      case 'trend_reversal':
        message = `üîÑ Ë∂ãÂäøÂèçËΩ¨ÊèêÈÜí\n\n`;
        message += `‰∫§ÊòìÂØπ: ${position.symbol} (${dirText})\n`;
        message += `${alertData.message}\n`;
        message += `EMA7: ${this.formatPrice(alertData.ema7)}\n`;
        message += `EMA25: ${this.formatPrice(alertData.ema25)}\n`;
        message += `Áõà‰∫è: ${pnl >= 0 ? '+' : ''}${pnl.toFixed(2)}%\n\n`;
        message += `‚ö†Ô∏è Âª∫ËÆÆ: Ë∂ãÂäøÂèçËΩ¨ÔºåËÄÉËôëÊ≠¢ÁõàÁ¶ªÂú∫\n`;
        message += `\n‚è∞ ${timeStr}`;
        break;

      case 'pattern_reversal':
        const patterns = alertData.patterns.map(p => `${p.emoji}${p.name}`).join('„ÄÅ');
        message = `üìä ÂΩ¢ÊÄÅÂèçËΩ¨ÊèêÈÜí\n\n`;
        message += `‰∫§ÊòìÂØπ: ${position.symbol} (${dirText})\n`;
        message += `Ê£ÄÊµãÂà∞: ${patterns}\n`;
        message += `Áõà‰∫è: ${pnl >= 0 ? '+' : ''}${pnl.toFixed(2)}%\n\n`;
        message += `‚ö†Ô∏è Âª∫ËÆÆ: Âá∫Áé∞ÂèçËΩ¨ÂΩ¢ÊÄÅÔºåËÄÉËôëÊ≠¢ÁõàÊàñÊî∂Á¥ßÊ≠¢Êçü\n`;
        message += `\n‚è∞ ${timeStr}`;
        break;

      default:
        message = `üìä ÊåÅ‰ªìÊèêÈÜí\n\n${position.symbol}: ${pnl >= 0 ? '+' : ''}${pnl.toFixed(2)}%`;
    }

    try {
      await this.bot.sendMessage(this.chatId, message);
      logger.info(`Position alert sent: ${position.symbol} (${type})`);
    } catch (err) {
      logger.error(`Failed to send position alert: ${err.message}`);
    }
  }
}

module.exports = { TelegramService };

